name: IPA Signing

on:
  # schedule:
    # - cron: '0 3 * * *' # Run daily at 3:00 AM UTC 
  workflow_dispatch: # Allow manual triggering

# Grant permissions to commit status file and manage releases
permissions:
  contents: write
  actions: read # Needed for gh release commands

env:
  CERT_REPO: "loyahdev/certificates"
  CERT_STATUS_FILE: "certificate_status.json"
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Use the default GitHub token
  SIGNING_INPUT_DIR: "signing_input"
  SIGNING_OUTPUT_DIR: "signing_output"
  SIGNED_IPAS_DIR: "signed_iPAs" # Final location within output dir
  BETA_RELEASE_TAG: "signed-ipas-beta"

jobs:
  sign_and_distribute:
    runs-on: ubuntu-latest
    outputs:
      signed_links: ${{ steps.generate_links.outputs.markdown_links }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: pip install Pillow argparse patool
        
      - name: Initialize Certificate Status File
        run: |
          if [ ! -f "$CERT_STATUS_FILE" ]; then
            echo '{}' > "$CERT_STATUS_FILE"
            echo "Initialized empty $CERT_STATUS_FILE"
          else
            echo "$CERT_STATUS_FILE already exists."
            # Ensure it's valid JSON or handle error
            if ! jq empty "$CERT_STATUS_FILE"; then
              echo "Error: $CERT_STATUS_FILE is not valid JSON. Resetting."
              echo '{}' > "$CERT_STATUS_FILE"
            fi
          fi

      - name: Fetch Latest Certificate Info from ${{ env.CERT_REPO }}
        id: cert_info
        run: |
          echo "Fetching latest release info from ${{ env.CERT_REPO }}..."
          # Get latest release JSON (not necessarily tagged 'latest')
          LATEST_RELEASE_JSON=$(gh release view --repo ${{ env.CERT_REPO }} --json tagName,body,assets)
          if [ -z "$LATEST_RELEASE_JSON" ]; then
            echo "Error: Could not fetch release info from ${{ env.CERT_REPO }}"
            exit 1
          fi

          echo "::group::Latest Release JSON"
          echo "$LATEST_RELEASE_JSON"
          echo "::endgroup::"

          # Parse details using jq
          TAG_NAME=$(echo "$LATEST_RELEASE_JSON" | jq -r '.tagName')
          BODY=$(echo "$LATEST_RELEASE_JSON" | jq -r '.body')

          # Extract UID and Revoked status from Body using grep/sed
          # Assuming UID is the only alphanumeric string after "UID=" on its line
          # Assuming Revoked is on its own line "Revoked: <value>"
          CERT_UID=$(echo "$BODY" | grep 'Subject:.*UID=' | sed -n 's/.*UID=\([a-zA-Z0-9]*\).*/\1/p')
          CERT_REVOKED_STR=$(echo "$BODY" | grep '^Revoked:' | sed 's/^Revoked: //')
          CERT_REVOKED=false
          if [[ "$CERT_REVOKED_STR" == "true" ]]; then
            CERT_REVOKED=true
          fi
          CERT_VALID_UNTIL=$(echo "$BODY" | grep '^Valid Until:' | sed 's/^Valid Until: //') # Optional but nice to have

          # Find the .zip asset URL (assuming only one .zip)
          CERT_ASSET_ZIP_URL=$(echo "$LATEST_RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".zip")) | .url')
          CERT_ASSET_ZIP_NAME=$(echo "$LATEST_RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".zip")) | .name')

          # Validate extracted info
          if [ -z "$CERT_UID" ] || [ -z "$CERT_ASSET_ZIP_URL" ]; then
            echo "Error: Could not parse required certificate details (UID or Asset URL) from release body/assets."
            echo "Body: $BODY"
            exit 1
          fi

          echo "Fetched Cert Name: ${CERT_ASSET_ZIP_NAME%.zip}"
          echo "Fetched Cert UID: $CERT_UID"
          echo "Fetched Cert Revoked: $CERT_REVOKED"
          echo "Fetched Cert Asset URL: $CERT_ASSET_ZIP_URL"
          echo "Fetched Cert Valid Until: $CERT_VALID_UNTIL"

          echo "cert_name=${CERT_ASSET_ZIP_NAME%.zip}" >> $GITHUB_OUTPUT
          echo "cert_uid=$CERT_UID" >> $GITHUB_OUTPUT
          echo "cert_revoked=$CERT_REVOKED" >> $GITHUB_OUTPUT
          echo "cert_asset_zip_url=$CERT_ASSET_ZIP_URL" >> $GITHUB_OUTPUT
          echo "cert_asset_zip_name=$CERT_ASSET_ZIP_NAME" >> $GITHUB_OUTPUT
          echo "cert_valid_until=$CERT_VALID_UNTIL" >> $GITHUB_OUTPUT
          echo "cert_tag=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Check Certificate Status and Decide Action
        id: cert_check
        run: |
          CURRENT_UID="${{ steps.cert_info.outputs.cert_uid }}"
          IS_REVOKED="${{ steps.cert_info.outputs.cert_revoked }}"
          STORED_JSON=$(cat "$CERT_STATUS_FILE")
          STORED_UID=$(echo "$STORED_JSON" | jq -r '.uid // empty')
          STORED_REVOKED=$(echo "$STORED_JSON" | jq -r .revoked)

          echo "Current Cert UID: $CURRENT_UID, Revoked: $IS_REVOKED"
          echo "Stored Cert UID: $STORED_UID, Revoked: $STORED_REVOKED"

          NEEDS_UPDATE=false
          PROCEED_WITH_SIGNING=false

          if [[ "$IS_REVOKED" == "true" ]]; then
            echo "Certificate $CURRENT_UID is REVOKED."
            if [[ "$STORED_UID" != "$CURRENT_UID" || "$STORED_REVOKED" != "true" ]]; then
              echo "Updating status file to reflect revocation."
              NEEDS_UPDATE=true
            else
              echo "Status file already reflects revocation. No action needed."
            fi
            PROCEED_WITH_SIGNING=false # Do not sign with a revoked certificate
          else
            echo "Certificate $CURRENT_UID is valid (not revoked)."
            PROCEED_WITH_SIGNING=true
            if [[ "$STORED_UID" != "$CURRENT_UID" || "$STORED_REVOKED" != "false" ]]; then
               echo "New certificate or status change detected. Status file needs update after signing."
               # We'll mark for update, but only commit *after* successful signing.
               NEEDS_UPDATE=true # Mark that an update is potentially needed
            else
               echo "Certificate status matches stored record. Exiting."
               # exit 1
            fi
          fi

          echo "needs_update=$NEEDS_UPDATE" >> $GITHUB_OUTPUT
          echo "proceed_signing=$PROCEED_WITH_SIGNING" >> $GITHUB_OUTPUT

      - name: Stop Workflow if Certificate is Revoked
        if: steps.cert_check.outputs.proceed_signing == 'false' && steps.cert_check.outputs.needs_update == 'false'
        run: |
          echo "Certificate is revoked and status file is up-to-date. Stopping workflow."
          exit 0 # Exit successfully, no signing needed

      - name: Update Status File for Revoked Cert (if needed) and Stop
        if: steps.cert_check.outputs.proceed_signing == 'false' && steps.cert_check.outputs.needs_update == 'true'
        run: |
          echo "Certificate is revoked. Updating status file and stopping."
          jq -n \
            --arg uid "${{ steps.cert_info.outputs.cert_uid }}" \
            --arg revoked "${{ steps.cert_info.outputs.cert_revoked }}" \
            --arg until "${{ steps.cert_info.outputs.cert_valid_until }}" \
            --arg tag "${{ steps.cert_info.outputs.cert_tag }}" \
            '{uid: $uid, revoked: ($revoked == "true"), valid_until: $until, last_checked_tag: $tag, last_update: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))}' > "$CERT_STATUS_FILE"

          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add "$CERT_STATUS_FILE"
          # Check if there are changes to commit
          if git diff --staged --quiet; then
             echo "No changes to commit to $CERT_STATUS_FILE."
          else
             git commit -m "Update certificate status: ${{ steps.cert_info.outputs.cert_uid }} (Revoked)"
             git push
             echo "Committed status file update."
          fi
          echo "Workflow stopped due to revoked certificate."
          # Use exit 1 to make the job fail clearly, indicating signing didn't happen
          exit 1

      # --- Steps below only run if proceed_signing is true ---

      - name: Download and Prepare Certificate Files
        if: steps.cert_check.outputs.proceed_signing == 'true'
        id: prep_cert_files
        run: |
          echo "Proceeding with signing using certificate ${{ steps.cert_info.outputs.cert_uid }}"
          CERT_ZIP_URL="${{ steps.cert_info.outputs.cert_asset_zip_url }}"
          CERT_ZIP_NAME="${{ steps.cert_info.outputs.cert_asset_zip_name }}"
          TEMP_CERT_DIR=$(mktemp -d)
          echo "Temporary certificate directory: $TEMP_CERT_DIR"

          echo "Downloading certificate asset: $CERT_ZIP_NAME from $CERT_ZIP_URL"
          curl -L -o "$TEMP_CERT_DIR/$CERT_ZIP_NAME" "$CERT_ZIP_URL"
          if [ $? -ne 0 ]; then echo "Error downloading certificate zip"; exit 1; fi

          echo "Unzipping certificate asset..."
          unzip -q "$TEMP_CERT_DIR/$CERT_ZIP_NAME" -d "$TEMP_CERT_DIR"
          if [ $? -ne 0 ]; then echo "Error unzipping certificate asset"; exit 1; fi

          # Find .p12, .mobileprovision, and password.txt
          P12_FILE=$(find "$TEMP_CERT_DIR" -maxdepth 1 -name '*.p12' | head -n 1)
          PROFILE_FILE=$(find "$TEMP_CERT_DIR" -maxdepth 1 -name '*.mobileprovision' | head -n 1)
          PASSWORD_FILE=$(find "$TEMP_CERT_DIR" -maxdepth 1 -name 'password.txt' | head -n 1)

          if [ -z "$P12_FILE" ] || [ -z "$PROFILE_FILE" ] || [ -z "$PASSWORD_FILE" ]; then
            echo "Error: Missing .p12, .mobileprovision, or password.txt in the downloaded zip."
            ls -l "$TEMP_CERT_DIR"
            exit 1
          fi

          CERT_PASSWORD=$(cat "$PASSWORD_FILE")
          if [ -z "$CERT_PASSWORD" ]; then
            echo "Error: password.txt is empty."
            exit 1
          fi
          # Mask the password in logs
          echo "::add-mask::$CERT_PASSWORD"

          # Prepare input directory for signing tool
          mkdir -p "$SIGNING_INPUT_DIR"
          cp "$P12_FILE" "$SIGNING_INPUT_DIR/"
          cp "$PROFILE_FILE" "$SIGNING_INPUT_DIR/"

          echo "Certificate files prepared in $SIGNING_INPUT_DIR"
          echo "p12_file=$(basename "$P12_FILE")" >> $GITHUB_OUTPUT
          echo "profile_file=$(basename "$PROFILE_FILE")" >> $GITHUB_OUTPUT
          echo "cert_password=$CERT_PASSWORD" >> $GITHUB_OUTPUT # Output password for use in next step

      - name: Download IPAs from Latest Release
        id: download_ipas
        if: steps.cert_check.outputs.proceed_signing == 'true'
        run: |
          echo "Downloading required IPA files..."
          # Get assets from the *latest* release of the current repo
          # Using `--latest` flag might not be reliable if you use pre-releases frequently.
          # Fetching the most recent non-prerelease, non-draft release:
          LATEST_TAG=$(gh release list --repo ${{ github.repository }} --exclude-drafts --exclude-pre-releases --limit 1 --json tagName | jq -r '.[0].tagName')
          echo "Latest tag:"
          echo $LATEST_TAG
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          cd "$SIGNING_INPUT_DIR"
          gh release download $LATEST_TAG -R ${{ github.repository }} --pattern "*.ipa"
          rm Agario.ipa
          
          if ! [  -n "$(ls -A)" ]; then
            echo "Warning: No .ipa files (excluding Agario.ipa) downloaded."
            touch .no_ipas_found # Create a marker file
          else
            echo "Found IPAs to download"
          fi

      - name: Install zsign
        if: steps.cert_check.outputs.proceed_signing == 'true'
        id: install_zsign
        run: |
          echo "Fetching latest zsign release info..."
          ZSIGN_RELEASE_JSON=$(gh release view --repo zhlynn/zsign --json assets)
          if [ -z "$ZSIGN_RELEASE_JSON" ]; then echo "Error fetching zsign release info"; exit 1; fi

          ZSIGN_ASSET_URL=$(echo "$ZSIGN_RELEASE_JSON" | jq -r '.assets[] | select(.name | contains("ubuntu-x64.zip")) | .url')
          ZSIGN_ASSET_NAME=$(echo "$ZSIGN_RELEASE_JSON" | jq -r '.assets[] | select(.name | contains("ubuntu-x64.zip")) | .name')

          if [ -z "$ZSIGN_ASSET_URL" ]; then echo "Error finding zsign ubuntu-x64 asset URL"; exit 1; fi

          echo "Downloading zsign asset: $ZSIGN_ASSET_NAME"
          curl -L -o "$ZSIGN_ASSET_NAME" "$ZSIGN_ASSET_URL"
          if [ $? -ne 0 ]; then echo "Error downloading zsign"; exit 1; fi

          ZSIGN_DIR="zsign_bin"
          mkdir "$ZSIGN_DIR"
          unzip -q "$ZSIGN_ASSET_NAME" -d "$ZSIGN_DIR"
          if [ $? -ne 0 ]; then echo "Error unzipping zsign"; exit 1; fi

          ZSIGN_BIN_PATH=$(find "$ZSIGN_DIR" -name 'zsign' -type f | head -n 1)
          if [ -z "$ZSIGN_BIN_PATH" ]; then echo "Error: zsign binary not found after unzip"; exit 1; fi

          chmod +x "$ZSIGN_BIN_PATH"
          echo "zsign_bin_path=$ZSIGN_BIN_PATH" >> $GITHUB_OUTPUT
          # Verify
          which $ZSIGN_BIN_PATH
          $ZSIGN_BIN_PATH -v

      - name: Download iPA-Edit Script
        if: steps.cert_check.outputs.proceed_signing == 'true'
        run: |
          IPAEDIT_URL="https://raw.githubusercontent.com/binnichtaktiv/iPA-Edit/8d2cd9dafc7f890ffb59f4bb20bc93fced736593/ipaedit.py"
          echo "Downloading iPA-Edit script from $IPAEDIT_URL"
          curl -L -O "$IPAEDIT_URL"
          if [ $? -ne 0 ]; then echo "Error downloading ipaedit.py"; exit 1; fi
          chmod +x ipaedit.py

      - name: Sign IPAs using iPA-Edit and zsign
        if: steps.cert_check.outputs.proceed_signing == 'true'
        run: |
          # Check if we actually downloaded any IPAs
          if [ -f ".no_ipas_found" ]; then
            echo "Skipping signing step as no IPAs were downloaded."
            exit 0
          fi

          # Check if input directory exists and has IPAs
          if [ ! -d "$SIGNING_INPUT_DIR" ] || [ -z "$(find "$SIGNING_INPUT_DIR" -maxdepth 1 -name '*.ipa')" ]; then
              echo "Error: Input directory '$SIGNING_INPUT_DIR' is missing or contains no IPA files."
              ls -l . # List current dir content for debugging
              exit 1
          fi
          
          ZSIGN_PATH="${{ steps.install_zsign.outputs.zsign_bin_path }}" # Get zsign binary path
          CERT_PASSWORD="${{ steps.prep_cert_files.outputs.cert_password }}" # Get cert password
          
          if [ -z "$ZSIGN_PATH" ]; then echo "Error: ZSIGN_PATH is empty."; exit 1; fi
          if [ ! -x "$ZSIGN_PATH" ]; then echo "Error: zsign binary not found or not executable at '$ZSIGN_PATH'"; exit 1; fi
          if [ -z "$CERT_PASSWORD" ]; then echo "Error: CERT_PASSWORD is empty."; exit 1; fi # Should be masked in logs

          echo "Running iPA-Edit..."
          echo "  zsign path: $ZSIGN_PATH"
          echo "  Input Dir: $SIGNING_INPUT_DIR"
          echo "  Output Dir: $SIGNING_OUTPUT_DIR"
          echo "  Using signing option: -s"
          
          # Pipe the path and password to the script's stdin
          printf "%s\n%s\n%s\n" "$ZSIGN_PATH" "Y" "$CERT_PASSWORD" | \
            python3 ./ipaedit.py -i "$SIGNING_INPUT_DIR" -o "$SIGNING_OUTPUT_DIR" -s

          if [ $? -ne 0 ]; then
            echo "Error running ipaedit.py"
            # Add more debug info if needed, e.g., list output dir contents
            ls -l "$SIGNING_OUTPUT_DIR"
            exit 1
          fi

          # Verify output directory exists
          if [ ! -d "$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR" ]; then
            echo "Error: Expected output directory '$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR' not found after running ipaedit.py."
            ls -l "$SIGNING_OUTPUT_DIR"
            exit 1
          fi

          echo "Signing complete. Signed IPAs are in $SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR"

      - name: Create or Update Beta Release and Upload Signed IPAs
        if: steps.cert_check.outputs.proceed_signing == 'true'
        run: |
          # Check if signing produced output
           if [ -f ".no_ipas_found" ]; then
            echo "Skipping release upload as no IPAs were processed."
            exit 0
          fi
          if [ ! -d "$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR" ] || [ -z "$(ls -A "$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR")" ]; then
            echo "Skipping release upload as no signed IPAs were found in $SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR"
            exit 0
          fi

          echo "Creating/Updating beta release: $BETA_RELEASE_TAG"
          # Check if release exists, create if not
          gh release view "$BETA_RELEASE_TAG" --repo ${{ github.repository }} > /dev/null 2>&1 || \
            gh release create "$BETA_RELEASE_TAG" \
              --repo ${{ github.repository }} \
              --title "Signed IPAs" \
              --notes "Automatically signed IPAs" \
              --prerelease

          echo "Uploading signed IPAs to release $BETA_RELEASE_TAG..."
          # Use --clobber to overwrite existing assets with the same name
          gh release upload "$BETA_RELEASE_TAG" "$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR"/* --clobber --repo ${{ github.repository }}
          if [ $? -ne 0 ]; then echo "Error uploading signed IPAs"; exit 1; fi
          echo "IPAs uploaded successfully."

      - name: Generate Installation Links and Update README
        # Only run if the previous steps indicate signing should proceed
        if: steps.cert_check.outputs.proceed_signing == 'true'
        id: update_readme_links
        run: |
          # === Initial Checks ===
          if [ -f ".no_ipas_found" ] || [ ! -d "$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR" ] || [ -z "$(ls -A "$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR")" ]; then
            echo "No signed IPAs found or output directory is empty. Skipping README update."
            exit 0
          fi

          # === Fetch Release Asset Info ===
          # We still need the asset URLs to submit to the preflight service
          echo "Fetching asset URLs from release $BETA_RELEASE_TAG..."
          RELEASE_ASSETS_JSON=$(gh release view "$BETA_RELEASE_TAG" --json assets --repo ${{ github.repository }})
          if [ $? -ne 0 ]; then
             echo "Error fetching assets from beta release $BETA_RELEASE_TAG. Cannot generate links."
             # Decide if this is a fatal error or if the workflow should continue without links
             # exit 1 # Uncomment if this should stop the workflow
             exit 0 # Exit step successfully but without doing anything
          fi
          if [ -z "$RELEASE_ASSETS_JSON" ] || [ "$(echo "$RELEASE_ASSETS_JSON" | jq '.assets | length')" -eq 0 ]; then
            echo "No assets found in release $BETA_RELEASE_TAG. Cannot generate links."
            exit 0
          fi

          # === Process IPAs and Modify README ===
          SIGNED_IPA_FILES=("$SIGNING_OUTPUT_DIR/$SIGNED_IPAS_DIR"/*.ipa)
          readme_modified=false # Flag to track if README was changed

          # Create a temporary file for the modified README
          temp_readme="README.md.tmp.$$" # Use PID for uniqueness
          cp README.md "$temp_readme"

          echo "Processing IPAs and updating README.md..."
          for ipa_file_path in "${SIGNED_IPA_FILES[@]}"; do
            ipa_filename=$(basename "$ipa_file_path")
            echo "Processing $ipa_filename..."

            # --- Get Download URL for Preflight Service ---
            # Find the *asset API URL* for this specific IPA asset from the release
            # The preflight service needs a URL it can fetch from.
            # Using browser_download_url might be better if the service can handle redirects
            # Let's try browser_download_url first as it's more stable/public
            ipa_download_url=$(echo "$RELEASE_ASSETS_JSON" | jq -r --arg name "$ipa_filename" '.assets[] | select(.name == $name) | .browser_download_url')

            if [ -z "$ipa_download_url" ] || [ "$ipa_download_url" == "null" ]; then
              echo "  Warning: Could not find browser_download_url for $ipa_filename in release assets. Trying asset URL..."
              # Fallback to API asset URL (might require auth for the service)
              ipa_download_url=$(echo "$RELEASE_ASSETS_JSON" | jq -r --arg name "$ipa_filename" '.assets[] | select(.name == $name) | .url')
              if [ -z "$ipa_download_url" ] || [ "$ipa_download_url" == "null" ]; then
                 echo "  Error: Could not find any download URL for $ipa_filename in release assets. Skipping link generation for this file."
                 continue # Skip to the next IPA
              fi
               echo "  Using API asset URL: $ipa_download_url"
            else
              echo "  Found browser download URL: $ipa_download_url"
            fi


            # --- Call Preflight Service ---
            echo "  Calling preflight service (ipa.s0n1c.ca)..."
            response=$(curl --request POST \
              --silent --show-error --fail \
              --url https://ipa.s0n1c.ca/preflight \
              --header 'Content-Type: application/json' \
              --data "{\"url\": \"$ipa_download_url\"}") # Use the URL found above

            if [ $? -ne 0 ]; then
              echo "  Error calling preflight service for $ipa_filename. Response: $response"
              # Consider logging the response body for debugging even on failure
              echo "  Response body: $response"
              continue # Skip to the next IPA
            fi

            # --- Extract ID and Construct Links ---
            install_id=$(echo "$response" | jq -r '.id')
            if [ -z "$install_id" ] || [ "$install_id" == "null" ]; then
              echo "  Error: Could not get 'id' from preflight response for $ipa_filename. Response: $response"
              continue # Skip to the next IPA
            fi
            echo "  Received ID: $install_id"

            itms_url="itms-services://?action=download-manifest&url=https://ipa.s0n1c.ca/${install_id}/manifest.plist"
            # URL for the install link in Markdown
            install_markdown_link_url="https://fwuf.in/#/${itms_url}"
            # Text to insert into README.md
            install_link_text_to_insert="[Install](${install_markdown_link_url}) / "

            # --- Define Target Link in README ---
            # The exact markdown for the direct download link we want to prepend to
            target_direct_download_link="[Direct download](https://github.com/${{ github.repository }}/releases/download/${{ steps.download_ipas.outputs.latest_tag }}/${ipa_filename})"

            # --- Check if Install Link Already Exists ---
            # Construct the pattern of the already modified line to avoid duplicate insertions
            already_inserted_pattern="${install_link_text_to_insert}${target_direct_download_link}"

            # Use grep -F for fixed string matching, -- for safety if a filename starts with '-'
            if grep -qF -- "$already_inserted_pattern" README.md; then
                echo "  Install link already seems to exist for $ipa_filename in README.md. Skipping modification."
                continue # Skip to next IPA
            fi

            # --- Modify README using awk for literal replacement (safer than shell loop for edge cases) ---
            # awk script:
            # - v_target: Variable holding the exact string to find
            # - v_insert: Variable holding the string to insert before the target
            # - index(\$0, v_target): Finds the first occurrence of the literal string v_target in the current line (\$0)
            # - If found (index > 0) and it's not already preceded by v_insert:
            #   - print the part before, the insert text, and the rest of the line
            #   - set replaced=1 and skip to next line (nextfile would be better but not posix)
            # - If not found or already replaced, print the line as is (the '1' at the end)
            # We process the current temp file and output to a new temp file for this specific IPA modification
            current_mod_temp="README.md.tmp.mod.$$"
            awk -v v_target="$target_direct_download_link" \
                -v v_insert="$install_link_text_to_insert" \
            '
            # --- Modify README using awk for literal replacement (safer than shell loop for edge cases) ---
            current_mod_temp="README.md.tmp.mod.$$"
            echo "  Applying awk transformation..." # Added logging

            # Use awk -f - to read the script from stdin via a heredoc <<'AWK_SCRIPT'
            # The single quotes around 'AWK_SCRIPT' prevent shell expansion within the script block.
            awk -v v_target="$target_direct_download_link" \
                -v v_insert="$install_link_text_to_insert" \
                -f - "$temp_readme" > "$current_mod_temp" <<'AWK_SCRIPT'
            BEGIN {
                replaced = 0
                # Optional: Debug print the variables awk received
                print "AWK: Target = <" v_target ">" > "/dev/stderr"
                print "AWK: Insert = <" v_insert ">" > "/dev/stderr"
            }
            {
                line = $0
                target_pos = index(line, v_target)
                # Construct the pattern that would exist if already inserted
                already_inserted_check_string = v_insert v_target
            
                # Check if target exists AND the already_inserted pattern isn't exactly there AND we haven't replaced yet
                # Using index > 0 correctly checks for existence.
                # index(line, already_inserted_check_string) != target_pos - length(v_insert) is complex;
                # simpler: check if the target exists AND the "already inserted" string does NOT exist at the same spot.
                # Let's refine the check slightly for clarity and robustness:
            
                # Does the target string exist on this line?
                if (target_pos > 0) {
                    # If it exists, does the *already inserted* pattern ALSO start exactly where it should?
                    # Calculate expected start position of the 'v_insert' part if it were there
                    expected_insert_pos = target_pos - length(v_insert)
            
                    # Check if the combined string exists and starts at the calculated position
                    already_present = (index(line, already_inserted_check_string) == expected_insert_pos)
            
                    # Proceed only if the target is found, it's not already present, and we haven't replaced yet in the file
                    if (!already_present && replaced == 0) {
                        # print "AWK: Modifying line: " NR > "/dev/stderr" # Debugging
                        # Reconstruct the line: part before + insertion + the rest (including original target)
                        print substr(line, 1, target_pos - 1) v_insert substr(line, target_pos)
                        replaced = 1 # Mark that we made a replacement (for the whole file)
                    } else {
                        # Target found, but already modified OR we already replaced elsewhere in the file
                        print line
                    }
                } else {
                    # Target not found on this line, print original line
                    print line
                }
            }
            END {
                print "AWK: Finished processing. Replaced flag = " replaced > "/dev/stderr" # Debugging
                # Exit with 0 if replacement happened (replaced=1), 1 otherwise (!1 is 0, !0 is 1)
                exit !replaced
            }
            AWK_SCRIPT

            awk_exit_code=$?
            if [ $awk_exit_code -eq 0 ]; then
               echo "  Successfully inserted link using awk."
               # Replace the main temp file with the newly modified one
               mv "$current_mod_temp" "$temp_readme"
               readme_needs_commit=true # Mark that a change happened
            elif [ $awk_exit_code -eq 1 ]; then
               echo "  Target direct download link not found for $ipa_filename in the expected format. No changes made by awk."
               rm "$current_mod_temp" # Clean up the intermediate temp file
            else
               echo "  Error: awk command failed with exit code $awk_exit_code while processing $ipa_filename."
               rm "$current_mod_temp" # Clean up
               # Decide if this is fatal
               # exit 1 # Or continue
            fi

          done # End of for loop iterating through IPAs

           # === Final Check and Commit ===
          # Check if the final temp file is actually different from the original README
          if [ "$readme_needs_commit" = true ] && ! cmp -s README.md "$temp_readme"; then
            echo "README.md was modified. Committing changes..."
            mv "$temp_readme" README.md # Overwrite original README with the final modified temp file

            # Configure Git user
            git config --global user.name 'github-actions[bot]'
            git config --global user.email 'github-actions[bot]@users.noreply.github.com'

            # Add, commit, and push
            git add README.md
            if git diff --staged --quiet; then
               echo "No changes staged, skipping commit (this shouldn't happen if cmp detected changes)."
            else
               git commit -m "docs: Update README with install links for ${BETA_RELEASE_TAG}" -m "Generated by GitHub Actions workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
               echo "Pushing changes to branch ${{ github.ref_name }}..."
               git push origin HEAD:${{ github.ref_name }}
               if [ $? -ne 0 ]; then
                   echo "Error: Failed to push README.md changes."
                   rm -f "$temp_readme" # Clean up just in case
                   exit 1
               else
                   echo "README.md update pushed successfully."
               fi
            fi
          else
            echo "No effective changes were made to README.md or no IPAs required updates."
            rm "$temp_readme" # Clean up the unmodified temp file
          fi

          echo "README update process finished."


      - name: Update Certificate Status File (After Success)
        # Only run if signing was attempted and needed update OR if it's a new cert
        if: steps.cert_check.outputs.proceed_signing == 'true' && steps.cert_check.outputs.needs_update == 'true'
        run: |
          echo "Updating status file with latest successful signing info for ${{ steps.cert_info.outputs.cert_uid }}."
          jq -n \
            --arg uid "${{ steps.cert_info.outputs.cert_uid }}" \
            --arg revoked "${{ steps.cert_info.outputs.cert_revoked }}" \
            --arg until "${{ steps.cert_info.outputs.cert_valid_until }}" \
            --arg tag "${{ steps.cert_info.outputs.cert_tag }}" \
            '{uid: $uid, revoked: ($revoked == "true"), valid_until: $until, last_checked_tag: $tag, last_update: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))}' > "$CERT_STATUS_FILE"

          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add "$CERT_STATUS_FILE"
           # Check if there are changes to commit
          if git diff --staged --quiet; then
             echo "No changes to commit to $CERT_STATUS_FILE."
          else
             git commit -m "Update certificate status: ${{ steps.cert_info.outputs.cert_uid }} (Valid/Used)"
             git push
             echo "Committed status file update."
          fi
